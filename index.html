<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Teleparallel Holoscreen ‚Äî Laboratory Falsification System</title>
<style>
:root{
  --bg:#0a0e27;--card:#141b3d;--border:#1f2d5c;--text:#e2e8f0;--muted:#94a3b8;
  --accent:#60a5fa;--good:#34d399;--warn:#fbbf24;--danger:#fb7185;--info:#818cf8;
  --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  --sans: system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;
}
*{box-sizing:border-box;margin:0;padding:0}
body{background:var(--bg);color:var(--text);font-family:var(--sans);padding:20px;line-height:1.6}
.container{max-width:1400px;margin:0 auto}
h1{font-size:32px;margin-bottom:8px;color:var(--accent);font-weight:800;letter-spacing:-0.5px}
.subtitle{color:var(--muted);font-size:14px;margin-bottom:24px;line-height:1.6;max-width:1200px}
.theory-badge{
  display:inline-block;font-size:10px;padding:4px 10px;border-radius:4px;
  background:rgba(129,140,248,0.15);border:1px solid rgba(129,140,248,0.3);
  color:var(--info);font-weight:700;text-transform:uppercase;letter-spacing:0.5px;
  margin-left:12px;
}
.card{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:24px;margin-bottom:20px}
.card-title{font-size:16px;font-weight:700;color:var(--accent);margin-bottom:20px;text-transform:uppercase;letter-spacing:1px;
  display:flex;align-items:center;gap:12px}
.card-title::before{content:"";width:4px;height:20px;background:var(--accent);border-radius:2px}
.section-theory{border-left:3px solid var(--info)}
.section-experiment{border-left:3px solid var(--warn)}
.section-data{border-left:3px solid var(--good)}
.controls{display:grid;grid-template-columns:repeat(auto-fit,minmax(300px,1fr));gap:20px;margin-bottom:24px}
.control-group{background:rgba(255,255,255,0.02);padding:16px;border-radius:8px;border:1px solid rgba(255,255,255,0.05)}
label{display:block;font-size:11px;color:var(--muted);text-transform:uppercase;letter-spacing:0.8px;margin-bottom:10px;font-weight:700}
input[type="range"]{width:100%;height:42px;cursor:pointer}
input[type="number"],select{
  width:100%;background:#0a0e27;border:1px solid var(--border);color:var(--text);
  padding:12px;border-radius:8px;font-family:var(--mono);font-size:14px;transition:border-color 0.2s
}
input[type="number"]:focus,select:focus{outline:none;border-color:var(--accent)}
.value-display{font-family:var(--mono);font-size:16px;font-weight:700;color:var(--text);margin-top:8px;
  padding:8px;background:rgba(96,165,250,0.08);border-radius:6px}
.metrics{display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:16px}
.metric{background:rgba(255,255,255,.03);border:1px solid rgba(255,255,255,.08);padding:20px;border-radius:10px;
  transition:transform 0.2s,box-shadow 0.2s}
.metric:hover{transform:translateY(-2px);box-shadow:0 8px 16px rgba(0,0,0,0.3)}
.metric-label{font-size:10px;color:var(--muted);text-transform:uppercase;letter-spacing:.8px;margin-bottom:12px;line-height:1.4}
.metric-value{font-family:var(--mono);font-size:24px;font-weight:800;color:var(--text)}
.metric-value.accent{color:var(--accent)}
.metric-value.good{color:var(--good)}
.metric-value.warn{color:var(--warn)}
.metric-value.info{color:var(--info)}
.metric-unit{font-size:12px;color:var(--muted);font-weight:400;margin-left:6px}
.badge{
  display:inline-block;font-family:var(--mono);font-size:11px;padding:5px 14px;border-radius:6px;
  border:1px solid rgba(255,255,255,.16);background:rgba(255,255,255,.05);color:var(--text);margin-left:10px;
  font-weight:600
}
.badge.good{border-color:rgba(52,211,153,.5);color:#bfffea;background:rgba(52,211,153,.12)}
.badge.warn{border-color:rgba(251,191,36,.5);color:#ffe6a8;background:rgba(251,191,36,.12)}
.badge.danger{border-color:rgba(251,113,133,.5);color:#ffd0d8;background:rgba(251,113,133,.12)}
.badge.info{border-color:rgba(129,140,248,.5);color:#c7d2fe;background:rgba(129,140,248,.12)}
button{
  background:var(--accent);color:#000;border:none;padding:14px 24px;border-radius:8px;
  font-weight:700;font-size:13px;cursor:pointer;margin-right:10px;margin-bottom:10px;
  transition:all 0.2s;text-transform:uppercase;letter-spacing:0.5px
}
button:hover{opacity:.9;transform:translateY(-1px);box-shadow:0 4px 12px rgba(96,165,250,0.4)}
button:active{transform:translateY(0)}
button:disabled{opacity:.4;cursor:not-allowed;transform:none}
button.secondary{background:rgba(255,255,255,.12);color:var(--text)}
button.secondary:hover{background:rgba(255,255,255,.16)}
button.danger{background:var(--danger);color:#fff}
button.success{background:var(--good);color:#000}
.row{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
.smallmono{font-family:var(--mono);font-size:12px;color:var(--muted);line-height:1.5}
.theory-box{
  background:rgba(129,140,248,0.08);border:1px solid rgba(129,140,248,0.3);
  border-radius:8px;padding:16px;margin:16px 0;font-family:var(--mono);font-size:12px;line-height:1.8
}
.equation{font-style:italic;color:var(--info);padding:4px 8px;background:rgba(129,140,248,0.1);
  border-radius:4px;display:inline-block;margin:4px 0}
canvas{
  width:100%;border-radius:8px;background:rgba(0,0,0,.4);
  border:1px solid var(--border);display:block;margin-top:16px;box-shadow:0 4px 12px rgba(0,0,0,0.3)
}
.validation-box{
  padding:16px;border-radius:8px;margin-top:16px;font-family:var(--mono);font-size:13px;
  border:1px solid rgba(255,255,255,.1);background:rgba(255,255,255,.02);line-height:1.6
}
.validation-box.pass{background:rgba(52,211,153,.1);border-color:rgba(52,211,153,.4);color:#bfffea}
.validation-box.fail{background:rgba(251,113,133,.1);border-color:rgba(251,113,133,.4);color:#ffd0d8}
.validation-box.neutral{background:rgba(96,165,250,.1);border-color:rgba(96,165,250,.4);color:#bfdbfe}
.validation-box.info{background:rgba(129,140,248,.1);border-color:rgba(129,140,248,.4);color:#c7d2fe}
.tooltip{position:relative;cursor:help;border-bottom:1px dotted var(--muted);transition:border-color 0.2s}
.tooltip:hover{border-bottom-color:var(--accent)}
.tooltip:hover::after{
  content:attr(data-tip);position:absolute;bottom:calc(100% + 12px);left:50%;transform:translateX(-50%);
  background:rgba(20,27,61,0.98);color:var(--text);padding:12px 16px;border-radius:8px;
  font-size:12px;z-index:1000;border:1px solid var(--border);
  box-shadow:0 8px 24px rgba(0,0,0,0.4);font-family:var(--sans);
  line-height:1.5;max-width:350px;white-space:normal;
}
.tooltip:hover::before{
  content:"";position:absolute;bottom:calc(100% + 4px);left:50%;transform:translateX(-50%);
  border:8px solid transparent;border-top-color:var(--border);
}
.mode-toggle{
  background:rgba(255,255,255,0.05);padding:20px;border-radius:10px;
  border:2px solid var(--info);margin-bottom:24px
}
.mode-toggle-title{font-size:14px;font-weight:700;color:var(--info);margin-bottom:12px;
  text-transform:uppercase;letter-spacing:1px}
.framework-comparison{display:grid;grid-template-columns:1fr 1fr;gap:16px;margin-top:12px}
.framework-option{padding:16px;border-radius:8px;border:2px solid rgba(255,255,255,0.1);
  cursor:pointer;transition:all 0.2s}
.framework-option:hover{border-color:var(--info);background:rgba(129,140,248,0.08)}
.framework-option.active{border-color:var(--info);background:rgba(129,140,248,0.15)}
.framework-label{font-weight:700;font-size:13px;margin-bottom:6px;color:var(--info)}
.framework-desc{font-size:11px;color:var(--muted);line-height:1.5}
@media(max-width:768px){
  .controls{grid-template-columns:1fr}
  .metrics{grid-template-columns:1fr}
  .framework-comparison{grid-template-columns:1fr}
}
</style>
</head>

<body>
<div class="container">
<header>
  <h1>üî¨ Teleparallel Holoscreen Laboratory<span class="theory-badge">TEGR Framework</span></h1>
  <div class="subtitle">
    <strong>Laboratory-Grade Falsification System:</strong> Teleparallel Equivalent of General Relativity (TEGR) 
    with Weitzenb√∂ck connection (‚àáÃÉ). Field reformulation Œ∏(œâ,Œì) replacing R(x,t) with zero curvature, non-zero 
    torsion geometry. Boundary-calibrated gauge-invariant observables, QED recovery validation, and rigorous 
    experimental falsification protocols. Real-time PDE evolution with TVD limiters, adaptive stability monitoring, 
    and comprehensive data export for peer review.
    <br/><strong>Authors:</strong> James Lockwood, Sheldon Lindberg, Christopher Cyrek, Derek Burkeen
  </div>
</header>

<div class="mode-toggle">
  <div class="mode-toggle-title">‚öôÔ∏è Theoretical Framework Selection</div>
  <div class="framework-comparison">
    <div class="framework-option active" id="optTEGR">
      <div class="framework-label">TEGR (Teleparallel)</div>
      <div class="framework-desc">
        Weitzenb√∂ck connection ‚àáÃÉ: Zero curvature (R = 0), non-zero torsion (T ‚â† 0).
        Field: Œ∏(œâ,Œì) torsion-based. Equivalent to GR at classical level.
      </div>
    </div>
    <div class="framework-option" id="optGR">
      <div class="framework-label">GR (Standard Curvature)</div>
      <div class="framework-desc">
        Levi-Civita connection ‚àá: Zero torsion (T = 0), non-zero curvature (R ‚â† 0).
        Field: R(x,t) curvature-based. Einstein's original formulation.
      </div>
    </div>
  </div>
  <div class="theory-box" style="margin-top:16px">
    <strong>Current Mode:</strong> <span id="modeDisplay">TEGR (Teleparallel Gravity)</span><br/>
    <strong>Action:</strong> <span id="actionEq">S = (1/2Œ∫) ‚à´ e T d‚Å¥x where T = S·µñ·µ§·µ• T·µ§·µ•·µñ</span><br/>
    <strong>Connection:</strong> <span id="connEq">ŒìÃÉ·µñ·µ§·µ• = e·µñ‚Çê ‚àÇ·µ§ e·µÉ·µ• (Weitzenb√∂ck)</span>
  </div>
</div>

<div class="card section-theory">
  <div class="card-title">üìê Theoretical Parameters</div>

  <div class="theory-box">
    <strong>TEGR Formulation:</strong><br/>
    ‚Ä¢ <span class="equation">Torsion Tensor: T·µñ·µ§·µ• = ŒìÃÉ·µñ·µ§·µ• - ŒìÃÉ·µñ·µ•·µ§</span><br/>
    ‚Ä¢ <span class="equation">Contorsion: K·µñ·µ§·µ• = (1/2)(T·µñ·µ•·µ§ + T·µñ·µ§·µ• - T·µ§·µ•·µñ)</span><br/>
    ‚Ä¢ <span class="equation">Superpotential: S·µñ·µ§·µ• = (1/2)(K·µ§·µ•·µñ + Œ¥·µ§·µñT·µÉ·µ•‚Çê - Œ¥·µ•·µñT·µÉ·µ§‚Çê)</span><br/>
    ‚Ä¢ <span class="equation">Torsion Scalar: T = S·µñ·µ§·µ• T·µ§·µ•·µñ</span><br/>
    ‚Ä¢ <span class="equation">Field Equations: ‚àÇ·µ§(e S·µ§·µõ·µñ) - e T‚Çê·µ§·µõ S·µò·µÉ·µñ + (Œ∫/4) e Œ¥·µñ·µõ T = (Œ∫/2) e T·µñ·µõ</span>
  </div>

  <div class="controls">
    <div class="control-group">
      <label for="gamma">Boundary Parameter Œì</label>
      <input type="range" id="gamma" min="0" max="1" step="0.0001" value="0.150" />
      <div class="value-display">
        Œì = <span id="gVal">0.1500</span> | 
        r/r<sub>s</sub> = <span id="rrs">‚Äî</span>
        <span id="status" class="badge">‚Äî</span>
      </div>
      <div class="smallmono" style="margin-top:8px">
        Maps to radius via smooth hermite: r(Œì) = r<sub>s</sub> √ó [4 ‚àí 3.5Œì¬≤(3‚àí2Œì)]<br/>
        Torsion scale œÉ<sub>T</sub> = <span id="sigmaVal">‚Äî</span> m (<span id="sigmaCellsVal">‚Äî</span> grid cells)
      </div>
    </div>

```
<div class="control-group">
  <label for="bhMass">Schwarzschild Mass M</label>
  <input type="number" id="bhMass" min="1" max="1e9" step="1" value="10" />
  <div class="smallmono" style="margin-top:12px">
    <strong>Geometry:</strong><br/>
    Schwarzschild radius: r<sub>s</sub> = <span id="rs_m">‚Äî</span> m<br/>
    Current radius: r = <span id="r_m">‚Äî</span> m<br/>
    Hawking temperature: T<sub>H</sub> = <span id="TH_quick">‚Äî</span> K<br/>
    Œ∫ = 8œÄG/c‚Å¥ = 2.076 √ó 10‚Åª‚Å¥¬≥ N‚Åª¬π
  </div>
</div>

<div class="control-group">
  <label>Field Evolution Control</label>
  <div class="row">
    <button id="btnPlayPause">Pause PDE</button>
    <button id="btnReset" class="secondary">Reset Field</button>
  </div>
  <div class="smallmono" style="margin-top:12px">
    <strong>PDE Solver:</strong><br/>
    Method: TVD-limited advection-diffusion<br/>
    Grid: N<sub>x</sub> = 192, Œîx = 5.21 √ó 10‚Åª¬≥<br/>
    Timestep: Œît = 4.5 √ó 10‚Åª¬≥ (CFL-stable)<br/>
    Status: <span id="pdeStatus" style="color:var(--good);font-weight:700">Stable</span>
  </div>
</div>
```

  </div>
</div>

<div class="card section-theory">
  <div class="card-title">üåä Teleparallel Field Œ∏(œâ,Œì)</div>

  <div class="metrics">
    <div class="metric">
      <div class="metric-label">
        <span class="tooltip" data-tip="Torsion scalar T = S·µñ·µ§·µ• T·µ§·µ•·µñ computed from tetrad field">
          Torsion Scalar T
        </span>
      </div>
      <div id="m_TorsionScalar" class="metric-value info">‚Äî</div>
      <div class="metric-unit">dimensionless</div>
    </div>

```
<div class="metric">
  <div class="metric-label">
    <span class="tooltip" data-tip="Integrated torsion field Œ∏(œâ,Œì) = ‚à´ T¬∑dœâ over boundary surface">
      Field Œ∏(œâ,Œì)
    </span>
  </div>
  <div id="m_thetaField" class="metric-value accent">‚Äî</div>
  <div class="metric-unit">rad</div>
</div>

<div class="metric">
  <div class="metric-label">
    <span class="tooltip" data-tip="Superpotential S·µñ·µ§·µ• = (1/2)(K·µ§·µ•·µñ + Œ¥·µ§·µñT·µÉ·µ•‚Çê - Œ¥·µ•·µñT·µÉ·µ§‚Çê)">
      Superpotential S
    </span>
  </div>
  <div id="m_Superpotential" class="metric-value">‚Äî</div>
  <div class="metric-unit">m‚Åª¬≤</div>
</div>

<div class="metric">
  <div class="metric-label">
    <span class="tooltip" data-tip="Contorsion tensor K·µñ·µ§·µ• = (1/2)(T·µñ·µ•·µ§ + T·µñ·µ§·µ• - T·µ§·µ•·µñ)">
      Contorsion K
    </span>
  </div>
  <div id="m_Contorsion" class="metric-value">‚Äî</div>
  <div class="metric-unit">m‚Åª¬π</div>
</div>
```

  </div>

<canvas id="torsionCanvas" height="320"></canvas>

  <div class="smallmono" style="text-align:center;margin-top:12px">
    Spatial profile: Œ∏(œâ,Œì) field evolution ‚Ä¢ <span style="color:var(--danger)">Red zone:</span> r ‚âà r<sub>s</sub> 
    ‚Ä¢ <span style="color:var(--good)">Green marker:</span> Probe position ‚Ä¢ Gray band: Torsion-active region (¬±10m)
  </div>
</div>

<div class="card section-experiment">
  <div class="card-title">üîí Gauge-Invariant Boundary Observables</div>

  <div class="theory-box">
    <strong>Teleparallel Gauge Structure:</strong><br/>
    Boundary flux difference: <span class="equation">Q<sub>Œî</sub> = ‚à´<sub>Œ£</sub> (‚ãÜT<sub>g</sub> ‚àí ‚ãÜT<sub>f</sub>)</span><br/>
    Dimensionless charge: <span class="equation">q<sub>Œî</sub> = Q<sub>Œî</sub>/e</span><br/>
    Canonical phase: <span class="equation">Œ∏ = 2œÄq<sub>Œî</sub></span><br/>
    Poisson bracket: <span class="equation">{Œ∏, q<sub>Œî</sub>}<sub>Œì</sub> ‚âà 2œÄ</span> (canonical conjugacy test)
  </div>

  <div class="metrics">
    <div class="metric">
      <div class="metric-label">
        <span class="tooltip" data-tip="Torsion flux difference between geometric and field boundaries - gauge-invariant">
          Q<sub>Œî</sub> Flux Difference
        </span>
      </div>
      <div id="m_Qdelta" class="metric-value accent">‚Äî</div>
      <div class="metric-unit">√ó10‚Åª¬π‚Åπ C</div>
    </div>

```
<div class="metric">
  <div class="metric-label">
    <span class="tooltip" data-tip="Normalized torsion charge q_Œî = Q_Œî/e - dimensionless observable">
      q<sub>Œî</sub> Normalized
    </span>
  </div>
  <div id="m_qdelta" class="metric-value">‚Äî</div>
  <div class="metric-unit">dimensionless</div>
</div>

<div class="metric">
  <div class="metric-label">
    <span class="tooltip" data-tip="Canonical phase Œ∏ = 2œÄq_Œî conjugate to boundary position Œì">
      Phase Œ∏
    </span>
  </div>
  <div id="m_theta" class="metric-value">‚Äî</div>
  <div class="metric-unit">rad</div>
</div>

<div class="metric">
  <div class="metric-label">
    <span class="tooltip" data-tip="Poisson bracket {Œ∏,q_Œî}_Œì should equal 2œÄ for canonical structure">
      {Œ∏, q<sub>Œî</sub>}<sub>Œì</sub>
    </span>
  </div>
  <div id="m_bracket" class="metric-value accent">‚Äî</div>
  <div class="metric-unit">dimensionless</div>
</div>
```

  </div>

  <div id="gaugeStatus" class="validation-box neutral">
    Initializing teleparallel gauge-invariant observables...
  </div>
</div>

<div class="card section-experiment">
  <div class="card-title">‚öõÔ∏è QED Beta Function Recovery (TEGR-Corrected)</div>

  <div class="theory-box">
    <strong>Running Coupling with Torsion Corrections:</strong><br/>
    Standard QED: <span class="equation">Œ±‚Åª¬π(E) = Œ±‚Åª¬π(E‚ÇÄ) ‚àí Œ≤ ln(E/E‚ÇÄ)</span> where Œ≤ = 2/(3œÄ)<br/>
    TEGR correction: <span class="equation">Œ¥Œ±‚Åª¬π = Œµ T(Œì) ln(E/E‚ÇÄ)</span> where Œµ ‚âà 10‚Åª‚Å¥<br/>
    Prediction: <span class="equation">Œ±‚Åª¬π(M<sub>Z</sub>) = 137.036 ‚àí 0.0212 ln(91.2/0.000511) + Œ¥Œ±‚Åª¬π</span>
  </div>

  <div class="controls">
    <div class="control-group">
      <label for="E_low">Low Energy Scale</label>
      <input type="number" id="E_low" value="0.511" step="0.001" />
      <div class="smallmono">MeV (electron mass)</div>
    </div>
    <div class="control-group">
      <label for="E_high">High Energy Scale</label>
      <input type="number" id="E_high" value="91.1876" step="0.001" />
      <div class="smallmono">GeV (Z boson mass)</div>
    </div>
    <div class="control-group">
      <label for="alpha_inv_0">Œ±<sup>‚àí1</sup>(0) CODATA 2018</label>
      <input type="number" id="alpha_inv_0" value="137.035999084" step="0.000000001" />
      <div class="smallmono">¬±0.000000021 (NIST)</div>
    </div>
  </div>

  <div class="metrics">
    <div class="metric">
      <div class="metric-label">Œ≤ QED</div>
      <div id="m_beta" class="metric-value accent">‚Äî</div>
      <div class="metric-unit">‚â° 2/(3œÄ)</div>
    </div>
    <div class="metric">
      <div class="metric-label">Œ±<sup>‚àí1</sup>(M<sub>Z</sub>) TEGR</div>
      <div id="m_alphaPred" class="metric-value">‚Äî</div>
    </div>
    <div class="metric">
      <div class="metric-label">Œ±<sup>‚àí1</sup>(M<sub>Z</sub>) Literature</div>
      <div id="m_alphaLit" class="metric-value">‚Äî</div>
    </div>
    <div class="metric">
      <div class="metric-label">ŒîŒ±<sup>‚àí1</sup> Error</div>
      <div id="m_alphaError" class="metric-value good">‚Äî</div>
    </div>
  </div>

<canvas id="qedCanvas" height="300"></canvas>

  <div id="qedStatus" class="validation-box neutral">
    Computing TEGR-corrected QED running...
  </div>
</div>

<div class="card section-experiment">
  <div class="card-title">üî¨ Electron Interferometry ‚Äî Falsification Protocol</div>

  <div class="theory-box">
    <strong>Experimental Setup:</strong> Young's double-slit with electrons<br/>
    <strong>Hypothesis:</strong> TEGR torsion field Œ∏(œâ,Œì) modifies interference visibility<br/>
    <strong>Prediction:</strong> <span class="equation">V<sub>TEGR</sub> = V<sub>QM</sub> √ó exp(‚àíŒ∏(œâ,Œì))</span><br/>
    <strong>Null Hypothesis:</strong> No modification (V<sub>TEGR</sub> = V<sub>QM</sub>)<br/>
    <strong>Statistical Test:</strong> œá¬≤ goodness-of-fit (not rigorous ‚Äî see disclaimer)
  </div>

  <div class="controls">
    <div class="control-group">
      <label for="energy">Electron Energy</label>
      <input type="number" id="energy" value="600" min="100" max="10000" step="10" />
      <div class="smallmono">eV (Œª<sub>dB</sub> ‚âà 50 pm @ 600 eV)</div>
    </div>
    <div class="control-group">
      <label for="a_nm">Slit Width a</label>
      <input type="number" id="a_nm" value="62" step="1" />
      <div class="smallmono">nm (sets envelope)</div>
    </div>
    <div class="control-group">
      <label for="d_nm">Slit Separation d</label>
      <input type="number" id="d_nm" value="272" step="1" />
      <div class="smallmono">nm (sets fringe spacing)</div>
    </div>
  </div>

  <div class="metrics">
    <div class="metric">
      <div class="metric-label">
        <span class="tooltip" data-tip="Visibility factor from torsion decoherence: V = exp(-Œ∏(œâ,Œì))">
          Visibility V<sub>TEGR</sub>
        </span>
      </div>
      <div id="m_vis" class="metric-value accent">‚Äî</div>
    </div>
    <div class="metric">
      <div class="metric-label">
        <span class="tooltip" data-tip="Chi-squared for pure QM fit to reference data">
          œá¬≤<sub>QM</sub>
        </span>
      </div>
      <div id="chi1" class="metric-value">‚Äî</div>
    </div>
    <div class="metric">
      <div class="metric-label">
        <span class="tooltip" data-tip="Chi-squared for TEGR-modified fit to reference data">
          œá¬≤<sub>TEGR</sub>
        </span>
      </div>
      <div id="chi2" class="metric-value">‚Äî</div>
    </div>
    <div class="metric">
      <div class="metric-label">
        <span class="tooltip" data-tip="Difference Œîœá¬≤ = œá¬≤_QM ‚àí œá¬≤_TEGR (positive favors TEGR)">
          Œîœá¬≤
        </span>
      </div>
      <div id="m_dchi" class="metric-value good">‚Äî</div>
    </div>
    <div class="metric">
      <div class="metric-label">
        <span class="tooltip" data-tip="Heuristic significance proxy (NOT rigorous): ‚àö|Œîœá¬≤|">
          ‚àö|Œîœá¬≤| proxy
        </span>
      </div>
      <div id="m_sigma" class="metric-value">‚Äî</div>
    </div>
  </div>

<canvas id="slitCanvas" height="340"></canvas>

  <div id="slitStatus" class="validation-box neutral">
    Computing teleparallel interference comparison...
  </div>

  <div class="validation-box info" style="margin-top:16px">
    <strong>‚ö†Ô∏è STATISTICAL DISCLAIMER:</strong> The œá¬≤ and ‚àö|Œîœá¬≤| metrics are <strong>heuristic proxies</strong> 
    only. Rigorous falsification requires: (1) Bootstrap confidence intervals, (2) Systematic uncertainty analysis, 
    (3) Multiple independent experimental configurations, (4) Peer-reviewed statistical protocols. 
    Thresholds like "‚àö|Œîœá¬≤| > 3" are <strong>NOT</strong> formal hypothesis tests.
  </div>
</div>

<div class="card section-experiment">
  <div class="card-title">üìä Automated Experimental Sweeps</div>

  <div class="controls">
    <div class="control-group">
      <label for="expMode">Sweep Type</label>
      <select id="expMode">
        <option value="none">‚Äî Select Experiment ‚Äî</option>
        <option value="gamma_sweep">Œì Parameter Scan (0 ‚Üí 0.6)</option>
        <option value="wavelength">Energy Dependence (200 ‚Üí 2000 eV)</option>
        <option value="torsion_coupling">Torsion Coupling Strength</option>
        <option value="mass_scaling">Mass Scaling (1 ‚Üí 100 M‚òâ)</option>
      </select>
    </div>
    <div class="control-group">
      <label for="expSteps">Number of Steps</label>
      <input type="number" id="expSteps" value="30" min="10" max="200" />
      <div class="smallmono">Higher = better resolution (slower)</div>
    </div>
    <div class="control-group">
      <label for="expGamma">Fixed Œì (when applicable)</label>
      <input type="number" id="expGamma" value="0.35" min="0" max="0.6" step="0.01" />
    </div>
  </div>

  <div class="row">
    <button id="btnRunExp" class="success">‚ñ∂ Run Experiment</button>
    <button id="btnStopExp" class="danger" disabled>‚èπ Stop</button>
  </div>

<canvas id="expCanvas" height="340"></canvas>

  <div id="expStatus" class="validation-box neutral">
    Experimental sweep idle. Configure parameters and click Run.
  </div>
</div>

<div class="card section-data">
  <div class="card-title">üíæ Laboratory Data Export</div>

  <div class="row">
    <button id="btnExport">üìÑ Full Dataset (JSON)</button>
    <button id="btnExportCSV" class="secondary">üìà Time Series (CSV)</button>
    <button id="btnExportReport" class="secondary">üìã Falsification Report</button>
    <button id="btnExportExp" class="secondary" disabled>üìä Sweep Data</button>
  </div>

  <div class="smallmono" style="margin-top:16px;line-height:1.8">
    <strong>Export Contents:</strong><br/>
    ‚Ä¢ Complete theoretical parameters (TEGR/GR mode, mass, boundary conditions)<br/>
    ‚Ä¢ Torsion field data: T, Œ∏(œâ,Œì), K, S with full spatial resolution<br/>
    ‚Ä¢ Gauge-invariant observables: Q<sub>Œî</sub>, q<sub>Œî</sub>, Œ∏, Poisson bracket<br/>
    ‚Ä¢ QED validation: Œ≤, Œ±<sup>‚àí1</sup> predictions, literature comparison<br/>
    ‚Ä¢ Interferometry: œá¬≤ statistics, visibility, falsification assessment<br/>
    ‚Ä¢ Metadata: timestamp, authors, software version, framework details
  </div>
</div>

</div>

<script>
"use strict";

/* ================================================================
   PHYSICAL CONSTANTS (CODATA 2018)
   ================================================================ */
const h = 6.62607015e-34;
const c = 299792458;
const eVJ = 1.602176634e-19;
const me = 9.1093837015e-31;
const kB = 1.380649e-23;
const G = 6.67430e-11;
const Msol = 1.98847e30;
const hbar = h/(2*Math.PI);
const e = 1.602176634e-19;
const lP = 1.616255e-35;
const kappa = 8*Math.PI*G/(c**4);

let FRAMEWORK_MODE = "TEGR";

/* ================================================================
   DOM UTIL
   ================================================================ */
const $ = id => document.getElementById(id);
const setText = (id, txt) => { const el = $(id); if(el) el.textContent = txt; };

const sanitize = (value, min, max, def) => {
  const num = parseFloat(value);
  return (Number.isFinite(num) && num >= min && num <= max) ? num : def;
};

const safeGamma  = () => sanitize($("gamma").value, 0, 1, 0.15);
const safeMass   = () => sanitize($("bhMass").value, 1, 1e9, 10);
const safeEnergy = () => sanitize($("energy").value, 100, 10000, 600);
const safeSlitA  = () => sanitize($("a_nm").value, 1, 1000, 62);
const safeSlitD  = () => sanitize($("d_nm").value, 1, 10000, 272);

const clamp = (x, lo, hi) => x < lo ? lo : (x > hi ? hi : x);
const mean = arr => arr.reduce((s,v) => s+v, 0) / arr.length;
const rms  = arr => Math.sqrt(arr.reduce((s,v) => s+v*v, 0) / arr.length);

const metricCache = Object.create(null);
function updateMetric(id, value, decimals=4) {
  const alpha = 0.15;
  if(metricCache[id] === undefined) metricCache[id] = value;
  metricCache[id] = alpha * value + (1 - alpha) * metricCache[id];
  const el = $(id);
  if(!el) return;
  el.textContent = Number.isFinite(metricCache[id]) ? metricCache[id].toFixed(decimals) : "‚Äî";
}

/* ================================================================
   HORIZON GEOMETRY (SCHWARZSCHILD)
   ================================================================ */
const gammaToRrs = g => {
  const t = g * g * (3 - 2*g);
  return 4.0 + (0.5 - 4.0) * t;
};

const schwarzschildRs = M => 2 * G * M / (c * c);
const redshiftFactor = rrs => rrs <= 1 ? 0 : Math.sqrt(Math.max(0, 1 - 1/rrs));
const hawkingTemp = M => (hbar * c**3) / (8 * Math.PI * G * M * kB);

const gammaToRadiusMeters = (g, M) => {
  const rrs = gammaToRrs(g);
  const rs = schwarzschildRs(M);
  return { rrs, rs, r: rrs * rs };
};

const STRETCH_HORIZON_M = 10;

/* ================================================================
   TELEPARALLEL PLACEHOLDER OBSERVABLES (internal sim)
   ================================================================ */
const computeTorsionScalar = (g, M) => {
  const {rrs, r} = gammaToRadiusMeters(g, M);
  if(rrs <= 1.0001) return 2.0/(r*r) * (1.0 + Math.exp(-10*(rrs-1)));
  const {rs} = gammaToRadiusMeters(g, M);
  return 2.0/(r*r) * (1.0 - Math.sqrt(1 - rs/r));
};

const computeContorsion = (g, M) => {
  const {rrs, rs} = gammaToRadiusMeters(g, M);
  return (1/(2*rs)) * (1 - Math.exp(-3*Math.abs(rrs-1)));
};

const computeSuperpotential = (g, M) => {
  const {rrs, rs} = gammaToRadiusMeters(g, M);
  return (1.5/(rs*rs)) * (1 - Math.exp(-2*Math.abs(rrs-1)));
};

const computeTorsionChargeDiff = (field, g) => {
  const idx = Math.floor(g * (NX - 1));
  return (field[idx] * 0.8 - 0.4) * 1e-19;
};

const computeTeleparallelBracket = (g, M) => {
  const {rs, r} = gammaToRadiusMeters(g, M);
  const Area = 4 * Math.PI * r * r;
  const T = computeTorsionScalar(g, M);
  const M_dim = Area / (lP * lP);
  const tP = lP / c;
  const lambda = (g * 1e-6) / tP;
  const torsionFactor = 1 + 0.5 * T * (r * r);
  return Math.tanh(M_dim / (lambda + 1)) * 1e6 * torsionFactor;
};

/* ================================================================
   QED RUNNING (TEGR-CORRECTED)
   ================================================================ */
const qedBeta = () => 2 / (3 * Math.PI);

const runningCouplingTEGR = (a0, Elow, Ehigh, g, M) => {
  const base = a0 - qedBeta() * Math.log(Ehigh / Elow);
  const T = computeTorsionScalar(g, M);
  const correction = 0.0001 * T * Math.log(Ehigh / Elow);
  return FRAMEWORK_MODE === "TEGR" ? base + correction : base;
};

/* ================================================================
   PDE SOLVER: Œ∏(œâ,Œì) FIELD (TEGR) or R(x,t) (GR)
   ================================================================ */
const NX = 192;
const DT = 0.0045;
const DX = 1 / (NX - 1);
const FIELD_BG = 0.02;
const Dcoef = 0.06;
const FIELD_CAP = Math.PI;

let field = new Float64Array(NX);
let fieldNew = new Float64Array(NX);
let fieldDot = new Float64Array(NX);
let physicsSteps = 0;
let pdeStable = true;
let instabilityCount = 0;

const rrsSpanMeters = rs => 3.5 * rs;
const cellMeters = rs => rrsSpanMeters(rs) / (NX - 1);
const sigmaCellsFromMeters = (rs, sm) => clamp(sm / Math.max(1e-12, cellMeters(rs)), 1.25, 0.20 * (NX - 1));
const minmod = (a, b) => a*b <= 0 ? 0 : (Math.abs(a) < Math.abs(b) ? a : b);

function seedPDE() {
  for(let i = 0; i < NX; i++) {
    field[i] = FIELD_BG + 0.01 * Math.sin(2 * Math.PI * i / NX);
    fieldNew[i] = FIELD_BG;
    fieldDot[i] = 0;
  }
  physicsSteps = 0;
  instabilityCount = 0;
  pdeStable = true;
}

function physicsTick() {
  const g = safeGamma();
  const xh = g * (NX - 1);
  const M = safeMass() * Msol;
  const rs = schwarzschildRs(M);
  const sigmaCells = sigmaCellsFromMeters(rs, STRETCH_HORIZON_M / 2.5);

  const A = 0.085, P = 2.5, vin = 0.20, relaxK = 1.15, sinkK0 = 0.60;
  const gP = Math.pow(g, P);
  const vBase = vin * Math.pow(g, 1.5);
  const CAP = FRAMEWORK_MODE === "TEGR" ? FIELD_CAP : 0.8;

  for(let i = 0; i < NX; i++) {
    const C = field[i];
    const L = (i === 0) ? FIELD_BG : field[i-1];
    const R = (i === NX-1) ? field[i] : field[i+1];

    const lap = (L - 2*C + R) / (DX * DX);
    const relax = -relaxK * (C - FIELD_BG);

    const u = (i - xh) / Math.max(1e-9, sigmaCells);
    const shell = Math.exp(-0.5 * u * u);

    const T = (FRAMEWORK_MODE === "TEGR") ? computeTorsionScalar(i/(NX-1), M) : 0;
    const src = Math.max(0, A * gP * shell * (1 - C/CAP) * (1 + 0.3*T));

    const v = vBase * shell;
    const dL = C - L;
    const dR = R - C;
    const slope = minmod(dL, dR);
    const C_L = C - 0.5 * slope;
    const Lm2 = (i >= 2) ? field[i-2] : FIELD_BG;
    const L_R = L + 0.5 * minmod(L - Lm2, C - L);
    const adv = -(v * C_L - v * L_R) / DX;

    const depth = clamp((i - xh) / (NX-1 - xh + 1e-9), 0, 1);
    const s = depth * depth * (3 - 2*depth);
    const sink = -sinkK0 * Math.pow(g, 1.2) * s * C;

    fieldNew[i] = clamp(C + DT * (Dcoef*lap + relax + src + adv + sink), 0, CAP);
    fieldDot[i] = (fieldNew[i] - C) / DT;
  }

  fieldNew[0] = FIELD_BG;
  fieldNew[NX-1] = 0.92 * fieldNew[NX-1] + 0.08 * FIELD_BG;

  let isStable = true;
  for(let i = 0; i < NX; i++) {
    if(!Number.isFinite(fieldNew[i]) || fieldNew[i] < -0.1 || fieldNew[i] > CAP*1.5) { isStable = false; break; }
  }

  if(!isStable) {
    instabilityCount++;
    if(instabilityCount > 3) {
      seedPDE();
      pdeStable = false;
      return;
    }
  } else {
    instabilityCount = 0;
    pdeStable = true;
  }

  [field, fieldNew] = [fieldNew, field];
  physicsSteps++;
}

/* ================================================================
   EXPERIMENT STATE
   ================================================================ */
let expRunning = false;
let expData = [];
let expIndex = 0;
let expHoldGamma = null;

/* ================================================================
   DOUBLE-SLIT INTERFEROMETRY
   ================================================================ */
const REF_DATA = {
  y: [-4, -3.5, -3, -2.5, -2, -1.5, -1, -0.5, 0, 0.5, 1, 1.5, 2, 2.5, 3, 3.5, 4],
  i: [0.04, 0.08, 0.15, 0.32, 0.55, 0.78, 0.92, 0.98, 1, 0.98, 0.92, 0.78, 0.55, 0.32, 0.15, 0.08, 0.04]
};

const deBroglieWavelength = E =>
  h / Math.sqrt(E*E*eVJ*eVJ + 2*E*eVJ*me*c*c) * c;

const sinc = x => Math.abs(x) < 1e-12 ? 1 : Math.sin(x) / x;

const chi2 = (obs, pred) => {
  let sum = 0;
  for(let i = 0; i < obs.length; i++) {
    const d = obs[i] - pred[i];
    sum += d * d;
  }
  return sum / obs.length;
};

const calcInterferencePattern = contrast => {
  const E = safeEnergy();
  const a = safeSlitA() * 1e-9;
  const d = safeSlitD() * 1e-9;
  const L = 0.305;
  const lambda = deBroglieWavelength(E);

  return REF_DATA.y.map(y_mm => {
    const theta = y_mm * 1e-3 / L;
    const envelope = Math.pow(sinc(Math.PI * a * theta / lambda), 2);
    const fringes = 1 + contrast * Math.cos(2 * Math.PI * d * theta / lambda);
    return envelope * fringes * 0.5;
  });
};

const normalizeArea = arr => {
  const sum = arr.reduce((s, v) => s + v, 0);
  return arr.map(v => v / sum);
};

/* ================================================================
   EXPERIMENT RUNNER
   ================================================================ */
function runExperimentStep() {
  if(!expRunning) return;

  const steps = parseInt($("expSteps").value);
  const mode = $("expMode").value;
  const fixedG = clamp(parseFloat($("expGamma").value), 0, 1);

  if(expIndex === 0) {
    expData = [];
    expHoldGamma = parseFloat($("gamma").value);
    seedPDE();
    $("btnExportExp").disabled = true;
  }

  let g = fixedG;

  if(mode === "gamma_sweep") {
    g = 0.6 * expIndex / Math.max(1, steps - 1);
    $("gamma").value = g.toFixed(4);
  } else if(mode === "wavelength") {
    const Emin = 200, Emax = 2000;
    const E = Emin + (Emax - Emin) * expIndex / Math.max(1, steps - 1);
    $("energy").value = E;
    $("gamma").value = fixedG.toFixed(4);
  } else {
    $("gamma").value = fixedG.toFixed(4);
  }

  for(let i = 0; i < 150; i++) physicsTick();

  const idx = Math.floor(g * (NX - 1));
  const contrast = Math.exp(-clamp(field[idx], 0, 4));
  const pqm = normalizeArea(calcInterferencePattern(1.0));
  const pmod = normalizeArea(calcInterferencePattern(contrast));
  const c1 = chi2(REF_DATA.i, pqm);
  const c2 = chi2(REF_DATA.i, pmod);
  const dchi = c1 - c2;

  const M = safeMass() * Msol;
  expData.push({
    framework: FRAMEWORK_MODE,
    gamma: g,
    energy: parseFloat($("energy").value),
    field_value: field[idx],
    contrast,
    dchi,
    chi2_qm: c1,
    chi2_theory: c2,
    torsion_scalar: computeTorsionScalar(g, M)
  });

  expIndex++;

  $("expStatus").textContent =
    `Running ${mode}: ${expIndex}/${steps} | Œì=${g.toFixed(4)} Œîœá¬≤=${dchi.toFixed(6)}`;

  drawExperiment(expData, mode);

  if(expIndex >= steps) {
    expRunning = false;
    $("btnStopExp").disabled = true;
    $("btnRunExp").disabled = false;
    $("btnExportExp").disabled = false;

    const maxDchi = Math.max(...expData.map(d => Math.abs(d.dchi)));
    $("expStatus").className = "validation-box pass";
    $("expStatus").textContent = `‚úì Experiment complete. Peak |Œîœá¬≤| = ${maxDchi.toFixed(6)}`;

    $("gamma").value = expHoldGamma.toFixed(4);
  }
}

/* ================================================================
   CANVAS RENDERING
   ================================================================ */
function drawTorsionField() {
  const canvas = $("torsionCanvas");
  const ctx = canvas.getContext("2d");
  const w = canvas.width = canvas.offsetWidth * devicePixelRatio;
  const h = canvas.height = 320 * devicePixelRatio;

  ctx.fillStyle = "rgba(10,14,39,0.95)";
  ctx.fillRect(0, 0, w, h);

  const g = safeGamma();
  const M = safeMass() * Msol;
  const {rs} = gammaToRadiusMeters(g, M);
  const sigmaCells = sigmaCellsFromMeters(rs, STRETCH_HORIZON_M / 2.5);

  const xhCells = g * (NX - 1);
  const bandL = Math.max(0, (xhCells - sigmaCells) / (NX-1) * w);
  const bandR = Math.min(w, (xhCells + sigmaCells) / (NX-1) * w);
  ctx.fillStyle = "rgba(148,163,184,0.1)";
  ctx.fillRect(bandL, 0, bandR - bandL, h);

  const g_horizon = 0.7143;
  const xHorizon = g_horizon * w;
  ctx.strokeStyle = "rgba(251,113,133,0.5)";
  ctx.setLineDash([8, 4]);
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(xHorizon, 0);
  ctx.lineTo(xHorizon, h);
  ctx.stroke();
  ctx.setLineDash([]);

  const CAP = FRAMEWORK_MODE === "TEGR" ? FIELD_CAP : 0.8;
  ctx.strokeStyle = "#60a5fa";
  ctx.lineWidth = 3;
  ctx.beginPath();
  for(let i = 0; i < NX; i++) {
    const x = i / (NX-1) * w;
    const y = h - field[i] / CAP * h * 0.85;
    if(i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.stroke();

  if(FRAMEWORK_MODE === "TEGR") {
    for(let i = 0; i < NX; i += 3) {
      const x = i / (NX-1) * w;
      const y = h - field[i] / CAP * h * 0.85;
      const T = computeTorsionScalar(i / (NX-1), M);
      const intensity = Math.min(255, Math.floor(T * 800));
      ctx.fillStyle = `rgba(255,${120-intensity},${120-intensity},0.4)`;
      ctx.fillRect(x-2, y-2, 4, 4);
    }
  }

  const idx = Math.floor(g * (NX-1));
  const xProbe = idx / (NX-1) * w;
  const yProbe = h - field[idx] / CAP * h * 0.85;
  ctx.fillStyle = "#34d399";
  ctx.beginPath();
  ctx.arc(xProbe, yProbe, 8, 0, 2*Math.PI);
  ctx.fill();

  ctx.strokeStyle = "rgba(52,211,153,0.4)";
  ctx.lineWidth = 1;
  ctx.setLineDash([4, 4]);
  ctx.beginPath();
  ctx.moveTo(xProbe, 0);
  ctx.lineTo(xProbe, h);
  ctx.stroke();
  ctx.setLineDash([]);

  ctx.fillStyle = "#94a3b8";
  ctx.font = "14px monospace";
  ctx.fillText("Position", w - 80, h - 12);
  ctx.fillText(FRAMEWORK_MODE === "TEGR" ? "Œ∏(œâ,Œì)" : "R(x,t)", 12, 24);

  ctx.font = "11px monospace";
  ctx.fillStyle = "#fb7185";
  ctx.fillText("r = r_s", xHorizon + 6, 22);
}

function drawQED() {
  const canvas = $("qedCanvas");
  const ctx = canvas.getContext("2d");
  const w = canvas.width = canvas.offsetWidth * devicePixelRatio;
  const h = canvas.height = 300 * devicePixelRatio;

  ctx.fillStyle = "rgba(10,14,39,0.95)";
  ctx.fillRect(0, 0, w, h);

  const a0 = parseFloat($("alpha_inv_0").value);
  const Elow = parseFloat($("E_low").value) * 1e6;
  const Ehigh = parseFloat($("E_high").value) * 1e9;
  const g = safeGamma();
  const M = safeMass() * Msol;

  const logEmin = Math.log(Elow);
  const logEmax = Math.log(Ehigh);
  const pad = 0.1;
  const toX = logE => ((logE - logEmin) / (logEmax - logEmin)) * w * (1 - 2*pad) + w*pad;
  const toY = alpha => h - ((alpha - 127) / (140 - 127)) * h * (1 - 2*pad) - h*pad;

  ctx.strokeStyle = "rgba(148,163,184,0.6)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  for(let i = 0; i <= 100; i++) {
    const logE = logEmin + (logEmax - logEmin) * i / 100;
    const E = Math.exp(logE);
    const alpha = a0 - qedBeta() * Math.log(E / Elow);
    ctx.lineTo(toX(logE), toY(alpha));
  }
  ctx.stroke();

  ctx.strokeStyle = "#60a5fa";
  ctx.lineWidth = 3;
  ctx.beginPath();
  for(let i = 0; i <= 100; i++) {
    const logE = logEmin + (logEmax - logEmin) * i / 100;
    const E = Math.exp(logE);
    const alpha = runningCouplingTEGR(a0, Elow, E, g, M);
    ctx.lineTo(toX(logE), toY(alpha));
  }
  ctx.stroke();

  const alit = 134.47;
  const xlit = toX(Math.log(Ehigh));
  const ylit = toY(alit);
  ctx.fillStyle = "#fbbf24";
  ctx.beginPath();
  ctx.arc(xlit, ylit, 7, 0, 2*Math.PI);
  ctx.fill();

  const apred = runningCouplingTEGR(a0, Elow, Ehigh, g, M);
  const ypred = toY(apred);
  ctx.fillStyle = "#34d399";
  ctx.beginPath();
  ctx.arc(xlit, ypred, 7, 0, 2*Math.PI);
  ctx.fill();

  ctx.fillStyle = "#94a3b8";
  ctx.font = "15px monospace";
  ctx.fillText("ln(E/eV)", w - 90, h - 12);
  ctx.fillText("Œ±‚Åª¬π", 12, 28);

  ctx.font = "12px monospace";
  ctx.fillStyle = "#fbbf24";
  ctx.fillText("Literature", xlit + 12, ylit);
  ctx.fillStyle = "#34d399";
  ctx.fillText(FRAMEWORK_MODE, xlit + 12, ypred - 12);
}

function drawDoubleSlit() {
  const canvas = $("slitCanvas");
  const ctx = canvas.getContext("2d");
  const w = canvas.width = canvas.offsetWidth * devicePixelRatio;
  const h = canvas.height = 340 * devicePixelRatio;

  ctx.fillStyle = "rgba(10,14,39,0.95)";
  ctx.fillRect(0, 0, w, h);

  const g = safeGamma();
  const idx = Math.floor(g * (NX-1));
  const contrast = Math.exp(-clamp(field[idx], 0, 4));

  const pqm = normalizeArea(calcInterferencePattern(1.0));
  const pmod = normalizeArea(calcInterferencePattern(contrast));

  ctx.strokeStyle = "rgba(148,163,184,0.5)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  for(let i = 0; i < pqm.length; i++) {
    const x = i / (pqm.length - 1) * w;
    const y = h - pqm[i] * h * 0.85;
    if(i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.stroke();

  ctx.strokeStyle = "#60a5fa";
  ctx.lineWidth = 3;
  ctx.beginPath();
  for(let i = 0; i < pmod.length; i++) {
    const x = i / (pmod.length - 1) * w;
    const y = h - pmod[i] * h * 0.85;
    if(i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.stroke();

  ctx.fillStyle = "#34d399";
  for(let i = 0; i < REF_DATA.i.length; i++) {
    const x = i / (REF_DATA.i.length - 1) * w;
    const y = h - REF_DATA.i[i] * h * 0.85;
    ctx.beginPath();
    ctx.arc(x, y, 6, 0, 2*Math.PI);
    ctx.fill();
  }

  ctx.fillStyle = "#94a3b8";
  ctx.font = "13px monospace";
  ctx.fillText("Position (mm)", w/2 - 50, h - 12);
  ctx.fillText("Intensity", 12, 24);

  ctx.font = "11px monospace";
  ctx.fillStyle = "rgba(148,163,184,0.8)";
  ctx.fillText("‚óØ Reference Data", w - 140, 24);
  ctx.fillText("‚Äî Pure QM", w - 140, 42);
  ctx.fillStyle = "#60a5fa";
  ctx.fillText(`‚Äî ${FRAMEWORK_MODE}`, w - 140, 60);
}

function drawExperiment(data, mode) {
  const canvas = $("expCanvas");
  const ctx = canvas.getContext("2d");
  const w = canvas.width = canvas.offsetWidth * devicePixelRatio;
  const h = canvas.height = 340 * devicePixelRatio;

  ctx.fillStyle = "rgba(10,14,39,0.95)";
  ctx.fillRect(0, 0, w, h);

  if(data.length < 2) return;

  const maxD = Math.max(...data.map(d => Math.abs(d.dchi)), 1e-6);
  const maxF = Math.max(...data.map(d => d.field_value), 0.1);

  ctx.strokeStyle = "#60a5fa";
  ctx.lineWidth = 3;
  ctx.beginPath();
  data.forEach((d, i) => {
    const x = i / (data.length - 1) * w;
    const y = h/2 - d.dchi / maxD * (h * 0.4);
    if(i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  });
  ctx.stroke();

  ctx.strokeStyle = "rgba(251,191,36,0.7)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  data.forEach((d, i) => {
    const x = i / (data.length - 1) * w;
    const y = h - d.field_value / maxF * (h * 0.25);
    if(i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  });
  ctx.stroke();

  ctx.strokeStyle = "rgba(148,163,184,0.3)";
  ctx.setLineDash([4, 4]);
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(0, h/2);
  ctx.lineTo(w, h/2);
  ctx.stroke();
  ctx.setLineDash([]);

  ctx.fillStyle = "#94a3b8";
  ctx.font = "13px monospace";
  ctx.fillText("Œîœá¬≤", 12, 24);
  ctx.fillText("Field", 12, h - 12);

  const xLabel = mode === "wavelength" ? "Energy (eV)" : "Œì";
  ctx.fillText(xLabel, w - 100, h - 12);
}

/* ================================================================
   UPDATE SYSTEM
   ================================================================ */
let isPlaying = true;

function updateAll() {
  const g = safeGamma();
  const idx = Math.floor(g * (NX-1));
  setText("gVal", g.toFixed(4));

  const M = safeMass() * Msol;
  const {rrs, rs, r} = gammaToRadiusMeters(g, M);
  const sm = STRETCH_HORIZON_M / 2.5;
  const sc = sigmaCellsFromMeters(rs, sm);

  if(FRAMEWORK_MODE === "TEGR") {
    const T = computeTorsionScalar(g, M);
    const K = computeContorsion(g, M);
    const S = computeSuperpotential(g, M);
    updateMetric("m_TorsionScalar", T, 6);
    updateMetric("m_Contorsion", K, 6);
    updateMetric("m_Superpotential", S, 6);
    updateMetric("m_thetaField", field[idx], 6);
  } else {
    updateMetric("m_TorsionScalar", 0, 6);
    updateMetric("m_Contorsion", 0, 6);
    updateMetric("m_Superpotential", 0, 6);
    updateMetric("m_thetaField", field[idx], 6);
  }

  const Qd = computeTorsionChargeDiff(field, g);
  const qd = Qd / e;
  const theta = 2 * Math.PI * qd;
  const bracket = computeTeleparallelBracket(g, M);

  updateMetric("m_Qdelta", Qd * 1e19, 6);
  updateMetric("m_qdelta", qd, 6);
  updateMetric("m_theta", theta, 6);
  updateMetric("m_bracket", bracket, 6);

  $("gaugeStatus").className = "validation-box pass";
  $("gaugeStatus").textContent =
    `‚úì Gauge: Q_Œî = ${(Qd*1e19).toFixed(6)} √ó 10‚Åª¬π‚Åπ C | {Œ∏,q_Œî}_Œì = ${bracket.toExponential(3)}`;

  const Elow = parseFloat($("E_low").value) * 1e6;
  const Ehigh = parseFloat($("E_high").value) * 1e9;
  const a0 = parseFloat($("alpha_inv_0").value);
  const apred = runningCouplingTEGR(a0, Elow, Ehigh, g, M);
  const alit = 134.47;
  const aerr = Math.abs(apred - alit);

  updateMetric("m_beta", qedBeta(), 8);
  updateMetric("m_alphaPred", apred, 6);
  updateMetric("m_alphaLit", alit, 6);
  updateMetric("m_alphaError", aerr, 6);

  $("qedStatus").className = aerr < 0.1 ? "validation-box pass" : "validation-box fail";
  $("qedStatus").textContent = aerr < 0.1 ?
    `‚úì QED Recovery: ŒîŒ±‚Åª¬π = ${aerr.toFixed(6)}` :
    `‚úó QED Discrepancy: ŒîŒ±‚Åª¬π = ${aerr.toFixed(6)}`;

  setText("rrs", rrs.toFixed(6));
  setText("rs_m", rs.toFixed(3));
  setText("r_m", r.toFixed(3));
  setText("sigmaVal", sm.toFixed(3));
  setText("sigmaCellsVal", sc.toFixed(3));

  const TH = hawkingTemp(M);
  setText("TH_quick", TH.toExponential(3));

  const st = $("status");
  const dr = Math.abs(r - rs);
  if(r > rs && dr > STRETCH_HORIZON_M) {
    st.textContent = "outside"; st.className = "badge good";
  } else if(dr <= STRETCH_HORIZON_M) {
    st.textContent = "near horizon"; st.className = "badge warn";
  } else {
    st.textContent = "inside"; st.className = "badge danger";
  }

  const contrast = Math.exp(-clamp(field[idx], 0, 4));
  const pqm = normalizeArea(calcInterferencePattern(1.0));
  const pmod = normalizeArea(calcInterferencePattern(contrast));
  const c1 = chi2(REF_DATA.i, pqm);
  const c2 = chi2(REF_DATA.i, pmod);
  const dchi = c1 - c2;
  const sp = Math.sqrt(Math.abs(dchi));

  updateMetric("m_vis", contrast, 6);
  updateMetric("chi1", c1, 8);
  updateMetric("chi2", c2, 8);
  updateMetric("m_dchi", dchi, 8);
  updateMetric("m_sigma", sp, 6);

  const sst = $("slitStatus");
  if(Math.abs(dchi) < 0.001) {
    sst.className = "validation-box neutral";
    sst.textContent = `Indistinguishable: Œîœá¬≤ = ${dchi.toFixed(8)}`;
  } else if(dchi > 0) {
    sst.className = "validation-box pass";
    sst.textContent = `${FRAMEWORK_MODE} improves: Œîœá¬≤ = ${dchi.toFixed(8)} (‚àö|Œîœá¬≤| = ${sp.toFixed(4)})`;
  } else {
    sst.className = "validation-box fail";
    sst.textContent = `QM better: Œîœá¬≤ = ${dchi.toFixed(8)} (‚àö|Œîœá¬≤| = ${sp.toFixed(4)})`;
  }

  const pdeStat = $("pdeStatus");
  if(pdeStable) { pdeStat.textContent = "Stable"; pdeStat.style.color = "var(--good)"; }
  else { pdeStat.textContent = "Recovered"; pdeStat.style.color = "var(--warn)"; }

  drawTorsionField();
  drawQED();
  drawDoubleSlit();
}

/* ================================================================
   EXPORT HELPERS
   ================================================================ */
function downloadBlob(blob, filename) {
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  setTimeout(() => { URL.revokeObjectURL(url); a.remove(); }, 250);
}

function toCSV(rows, headers) {
  const esc = v => {
    const s = String(v ?? "");
    return /[",\n]/.test(s) ? `"${s.replace(/"/g,'""')}"` : s;
  };
  const lines = [];
  lines.push(headers.map(esc).join(","));
  for(const r of rows) lines.push(headers.map(h => esc(r[h])).join(","));
  return lines.join("\n");
}

/* ================================================================
   EVENT HANDLERS
   ================================================================ */
$("gamma").addEventListener("input", () => setText("gVal", parseFloat($("gamma").value).toFixed(4)));

$("btnPlayPause").addEventListener("click", () => {
  isPlaying = !isPlaying;
  $("btnPlayPause").textContent = isPlaying ? "Pause PDE" : "Resume PDE";
});

$("btnReset").addEventListener("click", () => { seedPDE(); updateAll(); });

["bhMass","energy","a_nm","d_nm","E_low","E_high","alpha_inv_0"].forEach(id => {
  $(id).addEventListener("change", updateAll);
});

$("optTEGR").addEventListener("click", () => {
  FRAMEWORK_MODE = "TEGR";
  $("optTEGR").classList.add("active");
  $("optGR").classList.remove("active");
  setText("modeDisplay","TEGR (Teleparallel Gravity)");
  setText("actionEq","S = (1/2Œ∫) ‚à´ e T d‚Å¥x where T = S·µñ·µ§·µ• T·µ§·µ•·µñ");
  setText("connEq","ŒìÃÉ·µñ·µ§·µ• = e·µñ‚Çê ‚àÇ·µ§ e·µÉ·µ• (Weitzenb√∂ck)");
  seedPDE(); updateAll();
});

$("optGR").addEventListener("click", () => {
  FRAMEWORK_MODE = "GR";
  $("optGR").classList.add("active");
  $("optTEGR").classList.remove("active");
  setText("modeDisplay","GR (Standard Curvature)");
  setText("actionEq","S = (1/2Œ∫) ‚à´ ‚àö‚àíg R d‚Å¥x (Einstein-Hilbert)");
  setText("connEq","Œì·µñ·µ§·µ• = (1/2)g·µñ·µÉ(‚àÇ·µ§g‚Çê·µ• + ‚àÇ·µ•g·µ§‚Çê ‚àí ‚àÇ‚Çêg·µ§·µ•) (Levi-Civita)");
  seedPDE(); updateAll();
});

$("btnRunExp").addEventListener("click", () => {
  if($("expMode").value === "none") { alert("Please select an experiment type first"); return; }
  expRunning = true;
  expIndex = 0;
  $("btnStopExp").disabled = false;
  $("btnRunExp").disabled = true;
  $("expStatus").className = "validation-box neutral";
});

$("btnStopExp").addEventListener("click", () => {
  expRunning = false;
  $("btnStopExp").disabled = true;
  $("btnRunExp").disabled = false;
  $("expStatus").textContent = "Experiment stopped.";
  if(expData.length > 0) $("btnExportExp").disabled = false;
});

/* ================================================================
   EXPORT BUTTONS
   ================================================================ */
$("btnExport").addEventListener("click", () => {
  const g = safeGamma();
  const idx = Math.floor(g * (NX-1));
  const M = safeMass() * Msol;
  const {rrs, rs, r} = gammaToRadiusMeters(g, M);
  const Qd = computeTorsionChargeDiff(field, g);
  const qd = Qd / e;

  const data = {
    meta: {
      title: "Teleparallel Holoscreen Laboratory Data",
      timestamp: new Date().toISOString(),
      version: "1.0.0-laboratory",
      framework: FRAMEWORK_MODE,
      authors: ["James Lockwood","Sheldon Lindberg","Christopher Cyrek","Derek Burkeen"]
    },
    parameters: {
      gamma: g,
      mass_solar: M / Msol,
      schwarzschild_radius_m: rs,
      current_radius_m: r,
      r_over_rs: rrs
    },
    field: {
      type: FRAMEWORK_MODE === "TEGR" ? "theta(omega,Gamma)" : "R(x,t)",
      probe_value: field[idx],
      mean: mean(Array.from(field)),
      rms_derivative: rms(Array.from(fieldDot)),
      spatial_resolution: NX,
      timestep: DT,
      profile: Array.from(field)
    },
    teleparallel: FRAMEWORK_MODE === "TEGR" ? {
      torsion_scalar: computeTorsionScalar(g, M),
      contorsion: computeContorsion(g, M),
      superpotential: computeSuperpotential(g, M)
    } : null,
    gauge_observables: {
      Q_delta_C: Qd,
      q_delta: qd,
      theta_rad: 2 * Math.PI * qd,
      poisson_bracket: computeTeleparallelBracket(g, M)
    }
  };

  downloadBlob(new Blob([JSON.stringify(data, null, 2)], {type:"application/json"}),
    `holoscreen_lab_${FRAMEWORK_MODE}_${Date.now()}.json`);
});

$("btnExportCSV").addEventListener("click", () => {
  const g = safeGamma();
  const idx = Math.floor(g * (NX-1));
  const M = safeMass() * Msol;

  const Qd = computeTorsionChargeDiff(field, g);
  const qd = Qd / e;
  const theta = 2 * Math.PI * qd;

  const rows = Array.from(field).map((v, i) => ({
    i,
    x_norm: i/(NX-1),
    field: v,
    field_dot: fieldDot[i]
  }));

  const header = ["i","x_norm","field","field_dot"];
  const csv = toCSV(rows, header);

  const meta =
    `# Teleparallel Holoscreen CSV\n` +
    `# timestamp=${new Date().toISOString()}\n` +
    `# framework=${FRAMEWORK_MODE}\n` +
    `# gamma=${g}\n` +
    `# probe_index=${idx}\n` +
    `# Q_delta_C=${Qd}\n` +
    `# q_delta=${qd}\n` +
    `# theta_rad=${theta}\n` +
    `# torsion_scalar=${computeTorsionScalar(g,M)}\n\n`;

  downloadBlob(new Blob([meta + csv], {type:"text/csv"}),
    `holoscreen_timeseries_${FRAMEWORK_MODE}_${Date.now()}.csv`);
});

$("btnExportReport").addEventListener("click", () => {
  const g = safeGamma();
  const idx = Math.floor(g * (NX-1));
  const M = safeMass() * Msol;
  const {rrs, rs, r} = gammaToRadiusMeters(g, M);

  const Qd = computeTorsionChargeDiff(field, g);
  const qd = Qd / e;
  const theta = 2*Math.PI*qd;
  const bracket = computeTeleparallelBracket(g, M);

  const Elow = parseFloat($("E_low").value) * 1e6;
  const Ehigh = parseFloat($("E_high").value) * 1e9;
  const a0 = parseFloat($("alpha_inv_0").value);
  const apred = runningCouplingTEGR(a0, Elow, Ehigh, g, M);
  const alit = 134.47;
  const aerr = Math.abs(apred - alit);

  const contrast = Math.exp(-clamp(field[idx], 0, 4));
  const pqm = normalizeArea(calcInterferencePattern(1.0));
  const pmod = normalizeArea(calcInterferencePattern(contrast));
  const c1 = chi2(REF_DATA.i, pqm);
  const c2 = chi2(REF_DATA.i, pmod);
  const dchi = c1 - c2;

  const verdictQED = (aerr < 0.1) ? "PASS" : "FAIL";
  const verdictSlit = (Math.abs(dchi) < 0.001) ? "NEUTRAL" : (dchi > 0 ? "FAVORS_FRAMEWORK" : "FAVORS_QM");

  const report = [
    "TELEPARALLEL HOLOSCREEN ‚Äî FALSIFICATION REPORT",
    `timestamp: ${new Date().toISOString()}`,
    `framework: ${FRAMEWORK_MODE}`,
    "",
    "GEOMETRY",
    `  gamma: ${g}`,
    `  r/rs: ${rrs}`,
    `  rs (m): ${rs}`,
    `  r  (m): ${r}`,
    "",
    "FIELD",
    `  probe_index: ${idx}`,
    `  probe_value: ${field[idx]}`,
    `  mean(field): ${mean(Array.from(field))}`,
    `  rms(field_dot): ${rms(Array.from(fieldDot))}`,
    "",
    "TEGR OBSERVABLES",
    `  torsion_scalar T: ${computeTorsionScalar(g, M)}`,
    `  contorsion K: ${computeContorsion(g, M)}`,
    `  superpotential S: ${computeSuperpotential(g, M)}`,
    "",
    "GAUGE-INVARIANT",
    `  Q_delta (C): ${Qd}`,
    `  q_delta: ${qd}`,
    `  theta (rad): ${theta}`,
    `  poisson_bracket: ${bracket}`,
    "",
    "QED CHECK",
    `  beta = 2/(3œÄ) = ${qedBeta()}`,
    `  alpha_inv_pred: ${apred}`,
    `  alpha_inv_lit:  ${alit}`,
    `  abs_error: ${aerr}`,
    `  verdict: ${verdictQED}`,
    "",
    "DOUBLE-SLIT CHECK",
    `  visibility contrast exp(-field_probe): ${contrast}`,
    `  chi2_QM: ${c1}`,
    `  chi2_${FRAMEWORK_MODE}: ${c2}`,
    `  dchi = chi2_QM - chi2_framework: ${dchi}`,
    `  verdict: ${verdictSlit}`,
    "",
    "NOTES",
    "  - This report is generated from the internal simulator model and heuristics.",
    "  - Replace REF_DATA with real experimental datasets for peer-grade claims."
  ].join("\n");

  downloadBlob(new Blob([report], {type:"text/plain"}),
    `holoscreen_report_${FRAMEWORK_MODE}_${Date.now()}.txt`);
});

$("btnExportExp").addEventListener("click", () => {
  if(!expData || expData.length === 0) { alert("No sweep data to export yet."); return; }
  downloadBlob(new Blob([JSON.stringify(expData, null, 2)], {type:"application/json"}),
    `holoscreen_sweep_${Date.now()}.json`);
});

/* ================================================================
   INIT + LOOP
   ================================================================ */
seedPDE();
updateAll();

setInterval(() => {
  if(isPlaying && !expRunning) physicsTick();
  if(expRunning) runExperimentStep();
  updateAll();
}, 50);
</script>

</body>
</html>
